# HTTP Functions

> `.arc` abstracts API Gateway configuration and provisioning, while `@architect/functions` adds a very light but powerful API shim to Lambda for working with HTTP

Given the following example `.arc` file:

```arc
@app
testapp

@http
get /
```

By default, HTTP functions are dependency free with a minimal, but very powerful, low level API. 

```javascript
exports.handler = async function http(request) {
  return {
    status: 201,
    type: 'text/html; charset=utf8',
    body: `
    <!doctype html>
    <html>
      <body>hello world</body>
    </html>
   `
  }
}
```

Every HTTP handler receives a plain JavaScript object `request` as a first parameter with the following keys:

- <b>`body`</b> any `application/x-www-form-urlencoded` form variables as a plain `Object`
- <b>`path`</b> absolute path of the request
- <b>`method`</b> one of `GET`, `POST`, `PATCH`, `PUT` and `DELETE`
- <b>`params`</b> any URL params defined
- <b>`query`</b> any query params defined
- <b>`headers`</b> a plain `Object` of request headers 

To send a response HTTP functions support the following params as a plain JavaScript object:

- <b>`status`</b> or `code` sets the HTTP status code
- <b>`type`</b> set the `Content-Type` response header
- <b>`body`</b> set the response body
- <b>`location`</b> set the `Location` response header (combine w `status:302` to redirect)
- <b>`cookie`</b> set the `Set-Cookie` response header
- <b>`cors: true|false`</b> set the various CORS headers

## Layouts

Shared layouts are implemented using `src/shared`. Create the following file:

```javascript
// src/shared/layout.js
module.exports = function layout(html) {
  return `
    <!doctype html>
    <html>
    <body><h1>Layout!</h1>${html}</body>
    </html>
  `
}
```

And now from any other function you can reference it:

```javascript
// src/http/get-index/index.js
let layout = require('@architect/shared/layout')

module.exports = async function http(req) {
  let html = '<b>hello world!!</b>'
  return {
    type: 'text/html',
    body: layout(html)
  }
}
```

> ðŸ”¬ Read more about [sharing code guide](https://arc.codes/guides/sharing-common-code)

## Views

COMING SOON!

# Conveniences

HTTP functions come with `@architect/functions` and `@architect/data` installed which have convienant helpers for working with the unique API Gateway and DynamoDB environment characteristics.

```javascript
// opt into arc and data conveniences
let arc = require('@architect/functions')
let data = require('@architect/data')
```

The following API is supported:
 
- <b>`arc.http`</b> opt into an express-style middleware api
- <b>`arc.http.session.read`</b> read the session using the request cookie
- <b>`arc.http.session.write`</b> write the session returning a cookie string
- <b>`arc.http.helpers.url`</b> transform `/` into the appropriate `/staging` or `/production` API Gateway path
- <b>`arc.http.helpers.static`</b> accepts a path and returns path to `localhost:3333` or `staging` and `production` S3 buckets
- <b>`arc.http.helpers.verify`</b> verify a `csrf` token

> ðŸ“ˆ `@architect/functions` also has helpers for invoking SNS and SQS Lambda functions defined by `@events` and `@queues` respectively. You can read more about pub/sub patterns in the [background tasks guide](/guides/background-tasks).

## Sessions

HTTP functions can opt into session support:

```javascript
let arc = require('@architect/functions')

exports.handler = async function http(req) {

  // reads the session from DynamoDB
  let state = await arc.http.session.read(req) 

  // modify the state
  state.foo = 'bar'

  // save the session state to DynamoDB
  let cookie = await arc.http.session.write(state)

  // respond (and update the session cookie)
  return {
    cookie,
    status: 302,
    location: '/',
  }
}
```

All HTTP endpoints are sessions-enabled by default. 

- Session tables are automatically generated by `npx create` with the name `${appname}-staging-sessions` and `${appname}-production-sessions`, respectively 
- Requests are tagged to a session in DynamoDB via a signed cookie `_idx`
- Session data expires after a week of inactivity

## URLs

API Gateway generates long URLs that are hard to read, and extends the URL base path with either `staging` or `production` &mdash; this means a link intended to point at `/` should actually point at `/staging` or `/production`. This pain point is eased if you set up a [custom domain name with DNS](/guides/custom-dns).

`@architect/functions` also bundles a helper function `arc.http.helpers.url` for resolving URL paths that haven't yet been configured with DNS. This is helpful for early prototyping.

Here is an example index page that demonstrates `url` usage:

```javascript
let arc = require('@architect/functions')
let url = arc.http.helpers.url

exports.handler = async function http(req) {
  if (req.session.isLoggedIn) {
    return {
      type: 'text/html',
      body: `<a href=${url('/logout')}>logout</a>`
    }
  }
  else {
    return {
      status: 302,
      location: url('/login')
    } 
  }
}
```

> ðŸ‘‹ After DNS propagates you can remove calls to `arc.http.helpers.url` from your code. Learn how to [assign a domain name](/guides/custom-dns) by setting up DNS.

## Verify
COMING SOON

## Static
COMING SOON

## Examples

```javascript
exports.handler = async function http(req) {
  return {
    type: 'text/html'
    body: `<b>hello world</b>` 
  }
}
```

This redirects writing to the `session`:

```javascript
// src/http/post-login/index.js
let arc = require('@architect/functions')

exports.handler = async function http(req) {
  let loggedIn = req.body.email === 'admin' && req.body.password === 'admin'
  let cookie = await arc.http.session.write({loggedIn})
  return {
    cookie,
    status: 302,
    location: '/'
  }
}
```

This is a `302` response clearing the session data:

```javascript
let arc = require('@architect/functions')

exports.handler = async function http(req) {
  let cookie = await arc.http.session.write({})
  return {
    cookie,
    status: 302,
    location: '/'
  }
}
```

This is an example `500` response:

```javascript
exports.handler = async function http(req) {
  return {
    type: 'text/html',
    status: 500,
    body: 'internal serverless error'
  }
}
```

An example JSON API:

```javascript
exports.handler = async function http(req) {
  return {
    type: 'application/json',
    status: 201,
    body: JSON.stringify({cats: ['sutr0']})
  }
}
```

## Middleware Pattern

HTTP functions can also opt into Express-style middleware API. 

In this example we register `log`, `ping` and `index` to run in series. Each function signals to continue to the next function in the series by calling `next()`. Execution is halted at any time in the chain by calling `res`.

```javascript
let arc = require('@architect/functions')

function log(req, res, next) {
  console.log(JSON.stringify(req, null, 2))
  next()
}

function ping(req, res, next) {
  // does something with SNS here maybe
  next()
}

function index(req, res) {
  res({
    html: 'rendered index'
  })
}

exports.handler = arc.http(log, ping, index)
```


`req` has the following keys:

- `body` any `application/x-www-form-urlencoded` form variables as a plain `Object`
- `path` absolute path of the request
- `method` one of `GET`, `POST`, `PATCH`, `PUT` and `DELETE`
- `params` any URL params defined
- `query` any query params defined
- `headers` a plain `Object` of request headers
- `session` a plain `Object` representing the current session

## Response

`res` is a function that accepts named parameters:

- **Required**: One of
  - `json`
  - `html`
  - `text`
  - `css`
  - `js`
  - `xml`
  - `location`
- Optionally: `session` to assign to the current session
- Optionally: `status` of:
  - `400` Bad Request
  - `403` Forbidden
  - `404` Not Found
  - `406` Not Acceptable
  - `409` Conflict
  - `415` Unsupported Media Type
  - `500` Internal Serverless Error

The default HTTP status code is `200`. A `302` is sent automatically when redirecting via `location`.

---

## Example App

Let's implement a proof-of-concept login flow. [Example repo here.](https://github.com/arc-repos/arc-example-login-flow)

This example `.arc` brings together all the concepts for defining HTTP Lambdas:

```arc
@app
example-login-flow

@http
get /
get /logout
get /protected
post /login
```

`npx create` generates the following directory structure:

```bash
/
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ http
â”‚   â”‚   â”œâ”€â”€ get-index/
â”‚   â”‚   â”œâ”€â”€ get-logout/
â”‚   â”‚   â”œâ”€â”€ get-protected/
â”‚   â”‚   â””â”€â”€ post-login/
â”‚   â””â”€â”€ shared/
â”œâ”€â”€ .arc
â””â”€â”€ package.json
```

First we render a form for `/login` if `req.session.isLoggedIn` is `false`:

```javascript
let arc = require('@architect/functions')
let url = arc.http.helpers.url

function index(req, res) {
  var header = `<h1>Login Demo</h1>`
  var protec = `<a href=${url('/protected')}>protected</a>`
  var logout = `<a href=${url('/logout')}>logout</a>`
  var nav = `<p>${protec} | ${logout}</p>`

  var form = `
  <form action=${url('/login')} method=post>
    <label for=email>Email</label>
    <input type=text name=email>
    <label for=password>Password</label>
    <input type=password name=password>
    <button>Login</button>
  </form>
  `

  res({
    html: `${header} ${req.session.isLoggedIn? nav : form}`
  })
}

exports.handler = arc.http(index)
```

That form performs an HTTP `POST` to `/login` where we look for mock values in `req.body.email` and `req.body.password`:

```javascript
let arc = require('@architect/functions')
let url = arc.http.helpers.url

function route(req, res) {
  var isLoggedIn = req.body.email === 'admin' && req.body.password === 'admin'
  res({
    session: {isLoggedIn},
    location: url(`/`)
  })
}

exports.handler = arc.http(route)
```

If successful `req.session.isLoggedIn` will be `true` and `nav` gets rendered. `/protected` utilizes middleware to ensure only logged in users can see it.

```javascript
let arc = require('@architect/functions')
let url = arc.http.helpers.url

function protect(req, res, next) {
  if (req.session.isLoggedIn) {
    next()
  }
  else {
    res({
      location: url(`/`)
    })
  }
}

function attack(req, res) {
  var msg = 'oh hai you must be logged in to see me!'
  var logout = `<a href=${url('/logout')}>logout</a>`
  res({
    html: `${msg} ${logout}`
  })
}

exports.handler = arc.http(protect, attack)
```

Logging out just resets the `session` and redirects back to `/`.

```javascript
let arc = require('@architect/functions')
let url = arc.http.helpers.url

function route(req, res) {
  res({
    session: {},
    location: url(`/`)
  })
}

exports.handler = arc.http(route)
```

And that's it! [Find the example repo here.](https://github.com/arc-repos/arc-example-login-flow)

<hr>
## Next: [Static Assets](/guides/static-assets)
